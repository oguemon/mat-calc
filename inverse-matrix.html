<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>行列式・逆行列計算</title>
    <link rel="stylesheet" href="./main.css">
</head>
<body>
    <div id="header">
        <div class="wrapper">
            <div id="logo">行列式・逆行列計算</div>
        </div>
    </div>
    <div id="main-contents">
        <div class="wrapper">
            <div class="container">
                <div id="matrix_input"></div>
                <input type="button" id="dim_add" value="次元＋">
                <input type="button" id="dim_dec" value="次元ー">
                <input type="button" id="reset" value="リセット">
                <input type="button" id="calc" value="逆行列を計算">
                <div id="matrix_A"></div>
                <div id="det_answer"></div>
                <div id="matrix_revA"></div>
            </div>
        </div>
    </div>
    <div id="footer">
        <div class="wrapper">Copyright 2018 Oguemon All right reserved.</div>
    </div>
    <script>
    var btn_dimadd = document.getElementById('dim_add');
    var btn_dimdec = document.getElementById('dim_dec');
    var btn_reset  = document.getElementById('reset');
    var btn_calc   = document.getElementById('calc');
    var det_ans = document.getElementById('det_answer');
    var N = 3;

    window.onload = function ()
    {
        updateInputForm ();
    };

    /*
     *  次元を増やすボタンを押したら
     */
    btn_dimadd.onclick = function ()
    {
        N = Math.min(N+1, 10);
        updateInputForm ();
        return;
    }

    /*
     *  次元を減らすボタンを押したら
     */
    btn_dimdec.onclick = function ()
    {
        N = Math.max(N-1, 2);
        updateInputForm ();
        return;
    }

    /*
     *  リセットボタンを押したら
     */
     btn_reset.onclick = function ()
    {
        var agree = window.confirm("行列の中身を全てリセットします。\nよろしいでしょうか？");
        if (agree)
        {
            updateInputForm ();
        }
        return;
    }

    /*
     *  計算ボタンを押したら
     */
    btn_calc.onclick = function ()
    {
        var start_ms = new Date().getTime();
        var A = [];
        for (var i = 0; i < N * N; i++)
        {
            var tmp_value = document.getElementById('a-' + i).value;
            //本来はバリデーションを経る
            A[i] = tmp_value;
        }
        outputMat('matrix_A', A, 'A');
        
        var LU = makeLU(A);
        var rev_A = makeInverceA(LU);
        outputMat('matrix_revA', rev_A, 'A^{-1}');
        det_ans.innerHTML = makeDeterminant(LU);
        console.log('処理時間：' + (new Date().getTime() - start_ms) + ' ms');
        return;
    }

    /*
     *  フォームの描画
     */
     function updateInputForm ()
    {
        var mat_input = document.getElementById('matrix_input');
        var string = '';
        for (var i = 0; i < N * N; i++)
        {
            string += '<input type="text" id="a-' + i + '" name="matrix[]" value="'+Math.floor(Math.random()*10)+'">';
            if ((i + 1) % N == 0) string +='<br>';
        }

        mat_input.innerHTML = string;
    }

    /*
     *  行列をmathjaxで出力
     */
    function outputMat(id, matrix, name)
    {
        // 指定したidのエレメントを取得
        var ele = document.getElementById(id);
        // 出力文字列を更新
        var string = '$$' + name + ' = \\left(\\begin{array}{ccc}';
        for (var i = 0; i < matrix.length; i++)
        {
            string += Math.round(matrix[i]*1000)/1000
            string += ((i + 1) % N == 0) ? '\\\\' : ' & ';
        }
        string += '\\end{array}\\right),$$';
        // 指定したidに書き込み
        ele.innerHTML = string;
        // matjaxを更新
        MathJax.Hub.Typeset(ele);
        return;
    }

    /*
     *  行列式を求める
     */
    function makeDeterminant(LU)
    {
        var L = LU.L;
        var U = LU.U;

        var det = 1;

        // Uの対角成分の積を求める
        for (var i = 0; i < N; i++)
        {
            det *= LU.U[i + i * N];
        }

        return det;
    }

    /*
     *  掃き出し計算をして逆行列を求める
     *  (三角行列なので効率的)
     */
    function makeInverceA(LU)
    {
        var L = LU.L;
        var U = LU.U;

        // 逆行列が定義されるかどうかをチェック
        if (makeDeterminant(LU) == 0)
        {
            return false;
        }

        /*
         *  逆行列の卵を単位行列の形に初期化
         *  (単位行列にすることで効率化する)
         */
        var B = (new Array(L.length)).fill(0);
        var C = (new Array(L.length)).fill(0);
        for (var i = 0; i < N; i++)
        {
            B[i + i * N] = 1;
            C[i + i * N] = 1;
        }

        /*
         *  LC = EとなるC(即ちLの逆行列)を求める
         */
        // 左上から、行→列の順に走査
        for (var j = 0; j < N; j++)
        {
            for (var i = j; i < N; i++)
            {
                // Uにとって対角行列より右側を既出の値で計算
                for (var k = j; k < i; k++)
                {
                    C[j + i * N] -= L[k + i * N] * C[j + k * N];
                }
            }
        }

        /*
         *  UB = EとなるB(即ちUの逆行列)を求める
         */
        // 右下から、行→列の順に走査
        for (var j = N - 1; 0 <= j; j--)
        {
            for (var i = j; 0 <= i; i--)
            {
                // Uにとって対角行列より右側を既出の値で計算
                for (var k = j; i < k; k--)
                {
                    B[j + i * N] -= U[k + i * N] * B[j + k * N];
                }
                // 最後に対角成分で割る
                B[j + i * N] /= U[i + i * N];
            }
        }

        /*
         * A逆行列をU^(-1)L^(-1)から求める
         */
        var rev_UL = multSquareMatrix (B, C);
        var rev_A = [];
        for (var j = 0; j < LU.pivot.length; j++)
        {
            for (var i = 0; i < N; i++)
            {
                rev_A[LU.pivot[j] + i * N] = rev_UL[j + i * N];
            }
        }
        return rev_A;
    }

    // LU分解を行う
    function makeLU (A)
    {
        // 行の入れ替え状況を格納する配列
        var pivot = [];
        for (var i = 0; i < N; i++) {
            pivot[i] = i;
        }

        // i行目について扱う
        for (var i = 0; i < N - 1; i++)
        {
            /*
             * 対角成分が0にならないように行を入れ替え
             */
            // i+1行目以下のi列目成分の中で絶対値が最大のものを求める
            var max = {'line': i, 'value': Math.abs(A[i + i * N])};
            for (var j = i + 1; j < N; j++)
            {
                if (Math.abs(A[i + j * N]) > max.value)
                {
                    max.line  = j;
                    max.value = Math.abs(A[i + j * N]);
                }
            }
            // 最大が0だったら、i行目以下が全部0ということ（おしり）
            if (max.value == 0)
            {
                continue;
            }
            // 最大が0じゃなくて対角成分以上の行があった→行を入れ替える
            if (i != max.line)
            {
                for (var j = 0; j < N; j++)
                {
                    // 行の入れ替え
                    var tmp = A[j + i * N];
                    A[j + i * N] = A[j + max.line * N];
                    A[j + max.line * N] = tmp;
                }
                // ピボット配列（入替記録）の更新
                tmp = pivot[i]
                pivot[i] = pivot[max.line];
                pivot[max.line] = tmp;
            }

            /*
             * i行目のの割り算(U作り)
             */
            for (var j = i + 1; j < N; j++)
            {
                A[i + j * N] /= A[i + i * N];
            }
            /*
             * j行目とi列目で行列を作って余因子から引く
             */
            for (var n = i + 1; n < N; n++)
            {
                for (var m = i + 1; m < N; m++)
                {
                    A[m + n * N] -= A[m + i * N] * A[i + n * N];
                }
            }
        }

        // LとUを出す
        var L = A.slice();
        var U = A.slice();
        for (var i = 0; i < N; i++)
        {
            for (var j = 0; j < N; j++)
            {
                if (i < j)
                {
                    L[j + i * N] = 0;
                }
                else if (i > j)
                {
                    U[j + i * N] = 0;
                }
                else
                {
                    L[j + i * N] = 1;
                }
            }
        }

        return {'L': L, 'U': U, 'LxU': multSquareMatrix(L, U), 'pivot': pivot};
    }

    /*
     *  正方行列のかけ算をする（定義できないときはfalse）
     */
    function multSquareMatrix (A, B)
    {
        // AとBの要素数がマッチしない or 要素数が平方数じゃない
        if (A.length != B.length || !Number.isInteger(Math.pow(A.length, 0.5)))
        {
            return false;
        }

        var AB = [];
        var sum = 0;
        for (var i = 0; i < N; i++)
        {
            for (var j = 0; j < N; j++)
            {
                sum = 0;
                for (var k = 0; k < N; k++)
                {
                    sum += A[k + i * N] * B[j + k * N];
                }
                AB[j + i * N] = sum;
            }
        }

        return AB;
    }
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</body>
</html>