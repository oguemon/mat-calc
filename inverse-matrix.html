<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>行列式・逆行列計算</title>
</head>
<body>
    <script>
    for (var i = 0; i < 9; i++)
    {
        document.write('<input type="text" id="a-' + i + '" name="matrix[]" value="'+Math.floor(Math.random()*10)+'">');
        if (i % 3 == 2)
        {
            document.write('<br>');
        }
    }
    document.write('<input type="submit" id="det" name="det" value="行列式を計算">');
    document.write('<div id="det_answer"></div>');
    document.write('<div id="matrix_L"></div>');
    document.write('<div id="matrix_U"></div>');
    document.write('<div id="matrix_LxU"></div>');
    document.write('<div id="matrix_revA"></div>');
    var det_btn = document.getElementById('det');
    var det_ans = document.getElementById('det_answer');
    var mat_L = document.getElementById('matrix_L');
    var mat_U = document.getElementById('matrix_U');
    var mat_LxU = document.getElementById('matrix_LxU');
    var mat_revA = document.getElementById('matrix_revA');
    var matrix = [
         1,  1, -1,
        -2,  0,  1,
         0,  2,  1
    ];

    det_btn.onclick = function ()
    {
        N = Math.pow(matrix.length, 0.5); // 次元数
        mat_length = matrix.length; // 要素数
        for (var i = 0; i < mat_length; i++)
        {
            //var tmp_value = document.getElementById('a-' + i).value;
            //本来はバリデーションを経る
            //matrix[i] = tmp_value;
        }
        
        var tmp_det = [];
        tmp_det.push( matrix[0] * matrix[4] * matrix[8]);
        tmp_det.push(-matrix[0] * matrix[5] * matrix[7]);
        tmp_det.push(-matrix[1] * matrix[3] * matrix[8]);
        tmp_det.push( matrix[1] * matrix[5] * matrix[6]);
        tmp_det.push( matrix[2] * matrix[3] * matrix[7]);
        tmp_det.push(-matrix[2] * matrix[4] * matrix[6]); 
        var det_number = 0;
        for (var j = 0; j < tmp_det.length; j++) {
            det_number += tmp_det[j];
        };
        det_ans.innerHTML = det_number;
        
        var LU = makeLU(matrix);
        var rev_A = makeInverceA(LU);
        var L = '$$L = \\left(\\begin{array}{ccc}';
        var U = '$$U = \\left(\\begin{array}{ccc}';
        var LxU = '$$LU = \\left(\\begin{array}{ccc}';
        var revA = '$$A^{-1} = \\left(\\begin{array}{ccc}';
        for (var i = 0; i < mat_length; i++)
        {
            L += LU.L[i];
            U += LU.U[i];
            LxU += LU.LxU[i];
            revA += rev_A[i];
            if ((i + 1) % N == 0)
            {
                L += '\\\\';
                U += '\\\\';
                LxU += '\\\\';
                revA += '\\\\';
            }
            else
            {
                L += ' & ';
                U += ' & ';
                LxU += ' & ';
                revA += ' & ';
            }
        }
        L += '\\end{array}\\right),$$';
        U += '\\end{array}\\right),$$';
        LxU += '\\end{array}\\right),$$';
        revA += '\\end{array}\\right),$$';
        mat_L.innerHTML = L;
        mat_U.innerHTML = U;
        mat_LxU.innerHTML = LxU;
        mat_revA.innerHTML = revA;
        MathJax.Hub.Typeset(mat_L);
        MathJax.Hub.Typeset(mat_U);
        MathJax.Hub.Typeset(mat_LxU);
        MathJax.Hub.Typeset(mat_revA);
        console.log(LU.pivot);
        return;
    }
    // 吐き出し計算をする
    function makeInverceA(LU)
    {
        var L = LU.L;
        var U = LU.U;
        var N = Math.pow(L.length, 0.5)
        var B = (new Array(L.length)).fill(0);
        var C = (new Array(L.length)).fill(0);

        /*
         *  LC = EとなるC(即ちLの逆行列)を求める
         */
        // 左上から、行→列の順に走査
        for (var j = 0; j < N; j++)
        {
            for (var i = j; i < N; i++)
            {
                // 右辺(単位行列)の対角成分に対応
                if (i == j)
                {
                    C[j + i * N] = 1;
                }
                // Uにとって対角行列より右側を既出の値で計算
                for (var k = j; k < i; k++)
                {
                    C[j + i * N] -= L[k + i * N] * C[j + k * N];
                }
            }
        }

        /*
         *  UB = EとなるB(即ちUの逆行列)を求める
         */
        // 右下から、行→列の順に走査
        for (var j = N - 1; 0 <= j; j--)
        {
            for (var i = j; 0 <= i; i--)
            {
                // 右辺(単位行列)の対角成分に対応
                if (i == j)
                {
                    B[j + i * N] = 1;
                }

                // Uにとって対角行列より右側を既出の値で計算
                for (var k = j; i < k; k--)
                {
                    B[j + i * N] -= U[k + i * N] * B[j + k * N];
                }
                // 最後に対角成分で割る
                B[j + i * N] /= U[i + i * N];
            }
        }

        /*
         * A逆行列をU^(-1)L^(-1)から求める
         */
        var rev_UL = multSquareMatrix (B, C);
        var rev_A = [];
        for (var j = 0; j < LU.pivot.length; j++)
        {
            for (var i = 0; i < N; i++)
            {
                rev_A[LU.pivot[j] + i * N] = rev_UL[j + i * N];
            }
        }
        return rev_A;
    }

    // LU分解を行う
    function makeLU (A)
    {
        var N = Math.pow(A.length, 0.5)
        // 行の入れ替え状況を格納する配列
        var pivot = [];
        for (var i = 0; i < N; i++) {
            pivot[i] = i;
        }

        // i行目について扱う
        for (var i = 0; i < N - 1; i++)
        {
            /*
             * 対角成分が0にならないように行を入れ替え
             */
            // i+1行目以下のi列目成分の中で絶対値が最大のものを求める
            var max = {'line': i, 'value': Math.abs(A[i + i * N])};
            for (var j = i + 1; j < N; j++)
            {
                if (Math.abs(A[i + j * N]) > max.value)
                {
                    max.line  = j;
                    max.value = Math.abs(A[i + j * N]);
                }
            }
            // 最大が0だったら、i行目以下が全部0ということ（おしり）
            if (max.value == 0)
            {
                continue;
            }
            // 最大が0じゃなくて対角成分以上の行があった→行を入れ替える
            if (i != max.line)
            {
                for (var j = 0; j < N; j++)
                {
                    // 行の入れ替え
                    var tmp = A[j + i * N];
                    A[j + i * N] = A[j + max.line * N];
                    A[j + max.line * N] = tmp;
                }
                // ピボット配列（入替記録）の更新
                tmp = pivot[i]
                pivot[i] = pivot[max.line];
                pivot[max.line] = tmp;
            }

            /*
             * i行目のの割り算(U作り)
             */
            for (var j = i + 1; j < N; j++)
            {
                A[i + j * N] /= A[i + i * N];
            }
            /*
             * j行目とi列目で行列を作って余因子から引く
             */
            for (var n = i + 1; n < N; n++)
            {
                for (var m = i + 1; m < N; m++)
                {
                    A[m + n * N] -= A[m + i * N] * A[i + n * N];
                }
            }
        }

        // LとUを出す
        var L = A.slice();
        var U = A.slice();
        for (var i = 0; i < N; i++)
        {
            for (var j = 0; j < N; j++)
            {
                if (i < j)
                {
                    L[j + i * N] = 0;
                }
                else if (i > j)
                {
                    U[j + i * N] = 0;
                }
                else
                {
                    L[j + i * N] = 1;
                }
            }
        }

        return {'L': L, 'U': U, 'LxU': multSquareMatrix(L, U), 'pivot': pivot};
    }

    /*
     *  正方行列のかけ算をする（定義できないときはfalse）
     */
    function multSquareMatrix (A, B)
    {
        // AとBの要素数がマッチしない or 要素数が平方数じゃない
        if (A.length != B.length || !Number.isInteger(Math.pow(A.length, 0.5)))
        {
            return false;
        }
        
        var N = Math.pow(A.length, 0.5);
        var AB = [];
        for (var i = 0; i < N; i++)
        {
            for (var j = 0; j < N; j++)
            {
                var sum = 0;
                for (var k = 0; k < N; k++)
                {
                    sum += A[k + i * N] * B[j + k * N];
                }
                AB[j + i * N] = sum;
            }
        }

        return AB;
    }
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</body>
</html>